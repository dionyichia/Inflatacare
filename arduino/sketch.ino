/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/your_thing_id

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int alertStatus;
  int fRS1;
  int fRS2;
  int fRS3;
  int fRS4;
  int fRS5;
  int fRS6;
  int highestAccTime;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// Define analog pins for all 6 FRS sensors
const int FRS_PINS[] = {A0, A1, A2, A3, A4, A5};
const int NUM_SENSORS = 6;

// Connected sensors (set to true when physically connected)
const bool SENSOR_CONNECTED[] = {true, true, true, true, true, true}; // Only FRS1 and FRS2 are connected

// Thresholds
const int FORCE_THRESHOLD = 30;    // Pressure threshold (0-100%)
const unsigned long TIME_THRESHOLD = 30000; // 30 minutes in milliseconds
const unsigned long RESET_THRESHOLD = 10000; // 5 minutes below threshold to reset accumulated time

// Variables to track time over threshold
unsigned long thresholdStartTime[NUM_SENSORS] = {0};
unsigned long belowThresholdStartTime[NUM_SENSORS] = {0};
unsigned long accumulatedTime[NUM_SENSORS] = {0};
bool isOverThreshold[NUM_SENSORS] = {false};
bool alertActive[NUM_SENSORS] = {false};

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  
  // Current time
  unsigned long currentTime = millis();
  
  // Update bit-encoded alert status
  int newAlertStatus = 0;
  unsigned long maxAccTime = 0;
  
  // Read all sensors and process threshold logic
  for (int i = 0; i < NUM_SENSORS; i++) {
    int sensorValue;
    
    // Read sensor if connected, otherwise set to 0%
    if (SENSOR_CONNECTED[i]) {
      // Read and convert sensor value to percentage (inverted reading)
      sensorValue = ((1024.0 - analogRead(FRS_PINS[i])) / 1024.0) * 100.0;
    } else {
      // Default value for unconnected sensors (1024 = 0%)
      sensorValue = 0;
    }
    
    // Update corresponding cloud variable
    updateSensorValue(i, sensorValue);
    
    // Check if pressure exceeds threshold
    if (sensorValue > FORCE_THRESHOLD) {
      if (!isOverThreshold[i]) {
        // Just crossed threshold, record the time
        thresholdStartTime[i] = currentTime;
        isOverThreshold[i] = true;
      }
      // Add to accumulated time
      unsigned long elapsedOverThreshold = currentTime - thresholdStartTime[i];
      accumulatedTime[i] += elapsedOverThreshold;
      
      // Reset start time for next calculation
      thresholdStartTime[i] = currentTime;
      
      // Reset the below threshold timer
      belowThresholdStartTime[i] = 0;
    } else {
      // Below threshold
      if (isOverThreshold[i]) {
        // Just went below threshold, start the below-threshold timer
        belowThresholdStartTime[i] = currentTime;
        isOverThreshold[i] = false;
      } else if (belowThresholdStartTime[i] > 0) {
        // Check if we've been below threshold long enough to reset accumulated time
        if (currentTime - belowThresholdStartTime[i] >= RESET_THRESHOLD) {
          // Reset accumulated time after being below threshold for the reset period
          accumulatedTime[i] = 0;
          belowThresholdStartTime[i] = 0; // Reset the timer
          alertActive[i] = false;         // Clear any alert for this sensor
        }
      }
    }
    
    // Check if accumulated time exceeds threshold
    if (accumulatedTime[i] > TIME_THRESHOLD) {
      alertActive[i] = true;
      // Set the corresponding bit in the alert status
      newAlertStatus |= (1 << i);
    }
    
    // Find maximum accumulated time for highestAccTime cloud variable
    if (accumulatedTime[i] > maxAccTime) {
      maxAccTime = accumulatedTime[i];
    }
    
    // Print debug info
    Serial.print("Sensor ");
    Serial.print(i);
    Serial.print(": ");
    Serial.print(sensorValue);
    Serial.print("%, Acc Time: ");
    Serial.print(accumulatedTime[i] / 1000);
    Serial.print("s, Alert: ");
    Serial.println(alertActive[i] ? "YES" : "NO");
  }
  
  // Update cloud variables for alert status and highest accumulated time
  alertStatus = newAlertStatus;
  highestAccTime = maxAccTime / 1000; // Convert to seconds for cloud variable
  
  delay(1000); // Update once per second
}

// Helper function to update the right sensor cloud variable
void updateSensorValue(int sensorIndex, int value) {
  switch (sensorIndex) {
    case 0:
      fRS1 = value;
      break;
    case 1:
      fRS2 = value;
      break;
    case 2:
      fRS3 = value;
      break;
    case 3:
      fRS4 = value;
      break;
    case 4:
      fRS5 = value;
      break;
    case 5:
      fRS6 = value;
      break;
  }
}

/*
  Since FRS1 is READ_WRITE variable, onFRS1Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS1Change()  {
  // Add your code here to act upon FRS1 change
}

/*
  Since FRS2 is READ_WRITE variable, onFRS2Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS2Change()  {
  // Add your code here to act upon FRS2 change
}

/*
  Since FRS3 is READ_WRITE variable, onFRS3Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS3Change()  {
  // Add your code here to act upon FRS3 change
}

/*
  Since FRS4 is READ_WRITE variable, onFRS4Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS4Change()  {
  // Add your code here to act upon FRS4 change
}

/*
  Since FRS5 is READ_WRITE variable, onFRS5Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS5Change()  {
  // Add your code here to act upon FRS5 change
}

/*
  Since AlertStatus is READ_WRITE variable, onAlertStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAlertStatusChange()  {
  // Add your code here to act upon AlertStatus change
}
/*
  Since FRS6 is READ_WRITE variable, onFRS6Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onFRS6Change()  {
  // Add your code here to act upon FRS6 change
}

/*
  Since HighestAccTime is READ_WRITE variable, onHighestAccTimeChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHighestAccTimeChange()  {
  // Add your code here to act upon HighestAccTime change
}